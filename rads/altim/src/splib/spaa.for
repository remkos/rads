C- 
C-                   SUBPROGRAM LISTINGS
C-                     IN FORTRAN-77
C-
* These subroutines are described in and are copied from:
*
* 	   Samual D. Stearns and Ruth A. David
* 	      Signal Processing Algorithms
* Prentice-Hall, Englewood Cliffs, New Jersey, 1988
C-
C-
C-
C-***************************************************************
C-*                   CHAPTER 3 ROUTINES                        *
C-***************************************************************
C-
      SUBROUTINE SPDFTR(X,Y,N)
C-LATEST DATE: 02/18/87
C-COMPUTES THE DFT OF A REAL VECTOR X CONTAINING N DATA SAMPLES.
C-X IS DIMENSIONED X(0:N-1) OR LARGER.
C-Y IS COMPLEX Y(0:N/2) IF N EVEN, OR Y(0:(N-1)/2) IF N ODD.
C-INPUTS ARE X(0),X(1),...,X(N-1) AND N=NUMBER OF DATA SAMPLES.
C-OUTPUTS Y(0),Y(1),...,Y(N/2) IF N EVEN, OR Y(0),Y(1),...,
C-  Y((N-1)/2) IF N ODD, ARE THE COMPLEX DFT CONPONENTS, WITH
C-  COSINE COMPONENT=REAL PART AND SINE COMPONENT=IMAGINARY PART.
C-Y AND X CANNOT BE THE SAME ARRAY.
      DIMENSION X(0:N-1)
      COMPLEX Y(0:(N-1)/2),TPJN
      TPJN=CMPLX(0.,-8.*ATAN(1.)/N)
      DO 2 M=0,N/2
        Y(M)=X(0)
        DO 1 K=1,N-1
          Y(M)=Y(M)+X(K)*EXP(TPJN*K*M)
    1   CONTINUE
    2 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPIDTR(Y,X,N)
C-LATEST DATE: 11/12/85
C-SAME AS SPDFTR EXCEPT REVERSED; Y=SPECTRUM, X=OUTPUT TIME SERIES.
C-SPECTRAL DATA IS ASSUMED TO BE IN COMPLEX Y(0) THRU Y(N/2).
C-N=TIME SERIES LENGTH SHOULD BE EVEN.  TIME SERIES (SCALED BY N)
C-IS COMPUTED IN X(0) THRU X(N-1).  COMPLEX Y(0:N/2) AND DIMENSION
C-X(0:N-1) ARE ASSUMED, ALTHOUGH THE ARRAYS MAY BE LARGER.
      DIMENSION X(0:N-1)
      COMPLEX Y(0:N/2),TPJN
      TPJN=CMPLX(0.,8.*ATAN(1.)/N)
      DO 2 K=0,N-1
        X(K)=Y(0)+Y(N/2)*(-1)**K
        DO 1 M=1,N/2-1
          X(K)=X(K)+2.*REAL(Y(M)*EXP(TPJN*K*M))
    1   CONTINUE
    2 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPDFTC(X,Y,N,ISIGN)
C-LATEST DATE: 02/20/87
C-COMPUTES THE DFT OF A COMPLEX VECTOR X HAVING N COMPLEX SAMPLES.
C-X AND Y ARE SPECIFIED COMPLEX X(0:N-1),Y(0:N-1) OR LARGER.
C-INPUTS ARE X(0),X(1),...,X(N-1)=COMPLEX DATA VECTOR.
C-           N=NUMBER OF DATA SAMPLES.
C-           ISIGN=-1 FOR FORWARD OR +1 FOR INVERSE TRANSFORM.
C-OUTPUTS ARE Y(0),Y(1),...,Y(N-1)=COMPLEX DFT COMPONENTS, WITH
C-  COSINE COMPONENT=REAL PART AND SINE COMPONENT=IMAGINARY PART.
C-Y AND X CANNOT BE THE SAME ARRAY.
      COMPLEX X(0:N-1),Y(0:N-1),TPJN
      TPJN=CMPLX(0.,ISIGN*8.*ATAN(1.)/N)
      DO 2 M=0,N-1
        Y(M)=X(0)
        DO 1 K=1,N-1
          Y(M)=Y(M)+X(K)*EXP(TPJN*K*M)
    1   CONTINUE
    2 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPFFTR(X,N)
C-LATEST DATE: 11/12/85
C-FFT ROUTINE FOR REAL TIME SERIES (X) WITH N=2**K SAMPLES.
C-COMPUTATION IS IN PLACE, OUTPUT REPLACES INPUT.
C-DIMENSION X(0:N+1) (REAL; NOT COMPLEX) OR LARGER.
C-REAL TIME SERIES (INPUT) IS IN X(0) THRU X(N-1).
C-FIRST OUTPUT FFT COMPONENT IS X(0)=REAL PART; X(1)=IMAGINARY,
C-ETC.  LAST COMPONENT IS X(N)=REAL AND X(N+1)=IMAGINARY PART.
C-IMPORTANT:  N MUST BE AT LEAST 4 AND MUST BE A POWER OF 2.
      COMPLEX X(0:N/2),U,TMP
      TPN=8.*ATAN(1.)/N
      CALL SPFFTC(X,N/2,-1)
      X(N/2)=X(0)
      DO 1 M=0,N/4
        U=CMPLX(SIN(M*TPN),COS(M*TPN))
        TMP=((1.+U)*X(M)+(1.-U)*CONJG(X(N/2-M)))/2.
        X(M)=((1.-U)*X(M)+(1.+U)*CONJG(X(N/2-M)))/2.
        X(N/2-M)=CONJG(TMP)
    1 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPIFTR(X,N)
C-LATEST DATE: 02/20/87
C-INVERSE FFT OF THE COMPLEX SPECTRUM OF A REAL TIME SERIES.
C-X AND N ARE THE SAME AS IN SPFFTR.  IMPORTANT: N MUST BE A POWER
C-OF 2 AND X MUST BE DIMENSIONED X(0:N+1) (REAL ARRAY, NOT COMPLEX).
C-THIS ROUTINE TRANSFORMS THE OUTPUT OF SPFFTR BACK INTO THE INPUT,
C-SCALED BY N.  COMPUTATION IS IN PLACE, AS IN SPFFTR.
      COMPLEX X(0:N/2),U1,TMP
      TPN=8.*ATAN(1.)/N
      DO 1 M=0,N/4
        U1=CMPLX(SIN(M*TPN),-COS(M*TPN))
        TMP=(1.+U1)*X(M)+(1.-U1)*CONJG(X(N/2-M))
        X(M)=(1.-U1)*X(M)+(1.+U1)*CONJG(X(N/2-M))
        X(N/2-M)=CONJG(TMP)
    1 CONTINUE
      CALL SPFFTC(X,N/2,1)
      RETURN
      END
C-
      SUBROUTINE SPFFTC(X,N,ISIGN)
C-LATEST DATE: 02/20/87
C-FAST FOURIER TRANSFORM OF N=2**K COMPLEX DATA POINTS USING TIME
C-DECOMPOSITION WITH INPUT BIT REVERSAL.  N MUST BE A POWER OF 2.
C-X MUST BE SPECIFIED COMPLEX X(0:N-1)OR LARGER.
C-INPUT IS N COMPLEX SAMPLES, X(0),X(1),...,X(N-1).
C-COMPUTATION IS IN PLACE, OUTPUT REPLACES INPUT.
C-ISIGN = -1 FOR FORWARD TRANSFORM, +1 FOR INVERSE.
C-X(0) BECOMES THE ZERO TRANSFORM COMPONENT, X(1) THE FIRST,
C-AND SO FORTH.  X(N-1) BECOMES THE LAST COMPONENT.
      COMPLEX X(0:N-1),T
      PISIGN=4*ISIGN*ATAN(1.)
      MR=0
      DO 2 M=1,N-1
        L=N
    1   L=L/2
        IF(MR+L.GE.N) GO TO 1
        MR=MOD(MR,L)+L
        IF(MR.LE.M) GO TO 2
        T=X(M)
        X(M)=X(MR)
        X(MR)=T
    2 CONTINUE
      L=1
    3 IF(L.GE.N) RETURN
      DO 5 M=0,L-1
        DO 4 I=M,N-1,2*L
          T=X(I+L)*EXP(CMPLX(0.,M*PISIGN/FLOAT(L)))
          X(I+L)=X(I)-T
          X(I)=X(I)+T
    4   CONTINUE
    5 CONTINUE
      L=2*L
      GO TO 3
      END
C-
      COMPLEX FUNCTION SPCOMP(X,N,F)
C-LATEST DATE: 02/20/87
C-COMPUTES A SINGLE COMPLEX DFT COMPONENT OF A REAL VECTOR X.
C-X MUST BE SPECIFIED DIMENSION X(0:N-1) OR LARGER.
C-INPUTS ARE X(0),X(1),...,X(N-1) = REAL DATA SEQUENCE,
C-           N=NO. OF DATA SAMPLES.
C-           F=FREQUENCY IN HZ-S; SAMPLING FREQUENCY=1.0.
C-OUTPUT IS COMPLEX SPCOMP=COMPLEX DFT COMPONENT.  NOTE THAT
C-SPCOMP MUST BE DECLARED COMPLEX IN CALLING PROGRAM.
      DIMENSION X(0:N-1)
      RAD=8.*ATAN(1.)*F
      SPCOMP=X(0)
      DO 1 K=1,N-1
        SPCOMP=SPCOMP+X(K)*EXP(CMPLX(0.,-K*RAD))
    1 CONTINUE
      RETURN
      END
C- 
C-******************************************************************
C-*                   CHAPTER 4 ROUTINES                           *
C-******************************************************************
C-
      SUBROUTINE SPPOWR(X,Y,WORK,LX,LY,IWINDO,OVRLAP,NSGMTS,IERROR)
C-LATEST DATE: O2/20/87
C-COMPUTES RAW PERIODOGRAM, AVERAGED OVER SEGMENTS OF X(0:LX).
C-X(0),X(1),---,X(LX)=INPUT DATA SEQUENCE.
C-Y(0),Y(1),---,Y(LY)=OUTPUT PERIODOGRAM.  LY MUST BE A POWER OF 2.
C-WORK=WORK ARRAY DIMENSIONED AT LEAST WORK(0:2*LY+1).
C-LX=LAST INDEX IN DATA SEQUENCE AS ABOVE.
C-LY=FREQUENCY INDEX CORRESPONDING TO HALF SAMPLING RATE.  POWER OF 2.
C-SEGMENT LENGTH IS 2*LY.  DATA LENGTH (LX+1) MUST BE AT LEAST THIS BIG.
C-IWINDO=DATA WINDOW TYPE, 1(RECTANGULAR), 2(TAPERED RECTANGULAR),
C-  3(TRIANGULAR), 4(HANNING), 5(HAMMING), OR 6(BLACKMAN). SEE CH. 14.
C-OVRLAP=FRACTION THAT EACH DATA SEGMENT OF SIZE 2*LY OVERLAPS ITS
C-  PREDECESSOR.  MUST BE GREATER THAN OR EQUAL 0 AND LESS THAN 1.
C-NSGMTS=NO. OVERLAPPING SEGMENTS OF X AVERAGED TOGETHER.  OUTPUT.
C-IERROR=0  NO ERROR DETECTED.
C-       1  IWINDO OUT OF RANGE (1-6).
C-       2  LX TOO SMALL, I.E., LESS THAN 2*LY-1.
C-       3  LY NOT A POWER OF 2.
      DIMENSION X(0:LX),Y(0:LY),WORK(0:2*LY+1)
      IERROR=2
      IF(LX+1.LT.2*LY) RETURN
      IERROR=3
      BASE=LY
    1 BASE=BASE/2.
      IF(BASE-2.) 7,2,1
    2 DO 3 M=0,LY
        Y(M)=0.
    3 CONTINUE
      NSHIFT=MIN0(2*LY,MAX0(1,INT(2*LY*(1.-OVRLAP)+.5)))
      NSGMTS=1+(LX+1-2*LY)/NSHIFT
      DO 6 ISEGMT=0,NSGMTS-1
        DO 4 NSAMP=0,2*LY-1
          WORK(NSAMP)=X(NSHIFT*ISEGMT+NSAMP)
    4   CONTINUE
        CALL SPMASK(WORK,2*LY-1,IWINDO,TSV,IERROR)
        IF(IERROR.NE.0) RETURN
        CALL SPFFTR(WORK,2*LY)
        DO 5 M=0,LY
          Y(M)=Y(M)+(WORK(2*M)**2+WORK(2*M+1)**2)/(TSV*NSGMTS)
    5   CONTINUE
    6 CONTINUE
    7 RETURN
      END
C-
      FUNCTION SPRAND(ISEED)
C-LATEST DATE: 11/13/85
C-UNIFORM RANDOM NUMBER FROM 0.0 TO 1.0.
C-INITIALIZE BY SETTING ISEED, THEN LEAVE ISEED ALONE.
      ISEED=2045*ISEED+1
      ISEED=ISEED-(ISEED/1048576)*1048576
      SPRAND=FLOAT(ISEED+1)/1048577.0
      RETURN
      END
C-
      SUBROUTINE SPCROS(X1,X2,Y,WORK,LX,LY,IWINDO,OVRLAP,NSGMTS,IERROR)
C-LATEST DATE: 02/20/87
C-SIMILAR TO SPPOWR, BUT FOR THE AVG. CROSS-SPECTRUM OF 2 SEQUENCES.
C-X1(0) THRU X1(LX) AND X2(0) THRU X2(LX) ARE THE INPUT DATA SEQUENCES.
C-COMPLEX Y(0),Y(1),---,Y(LY)=OUTPUT SPECTRUM.  LY=POWER OF 2.
C-WORK=COMPLEX WORK ARRAY DIMENSIONED AT LEAST WORK(0:2*LY-1).
C-LX=LAST INDEX IN INPUT DATA SEQUENCES AS ABOVE.
C-LY=FREQUENCY INDEX CORRESP. TO HALF SAMPLING RATE=POWER OF 2.
C-SEGMENT LENGTH IS 2*LY.  DATA LENGTH (LX+1) MUST BE AT LEAST THIS BIG.
C-IWINDO=DATA WINDOW TYPE, 1(RECTANGULAR), 2(TAPERED RECTANGULAR),
C-  3(TRIANGULAR), 4(HANNING), 5(HAMMING), OR 6(BLACKMAN).  SEE CH. 14.
C-OVRLAP=FRACTION THAT EACH DATA SEGMENT OF SIZE 2*LY OVERLAPS ITS
C- PREDECESSOR.  MUST BE GREATER THAN OR EQUAL 0 AND LESS THAN 1.
C-NSGMTS=NO. OVERLAPPING SEGMENTS OF X AVERAGED TOGETHER.  OUTPUT.
C-IERROR=0  NO ERROR DETECTED.
C-       1  IWINDO OUT OF RANGE (1-6).
C-       2  LX TOO SMALL, I.E., LESS THAN 2*LY-1.
C-       3  LY NOT A POWER OF 2.
      DIMENSION X1(0:LX),X2(0:LX)
      COMPLEX Y(0:LY),WORK(0:2*LY-1)
      IERROR=1
      IF(IWINDO.LT.1.OR.IWINDO.GT.6) RETURN
      IERROR=2
      IF(LX+1.LT.2*LY) RETURN
      IERROR=3
      BASE=LY
    1 BASE=BASE/2.
      IF(BASE-2.) 7,2,1
    2 DO 3 M=0,LY
        Y(M)=(0.,0.)
    3 CONTINUE
      NSHIFT=MIN0(2*LY,MAX0(1,INT(2*LY*(1.-OVRLAP)+.5)))
      NSGMTS=1+(LX+1-2*LY)/NSHIFT
      TSV=0.
      DO 6 ISEGMT=0,NSGMTS-1
        DO 4 NSAMP=0,2*LY-1
          W=SPWNDO(IWINDO,2*LY,NSAMP)
          IF(ISEGMT.EQ.0) TSV=TSV+W*W
          INDEX=NSHIFT*ISEGMT+NSAMP
          WORK(NSAMP)=CMPLX(W*X1(INDEX),W*X2(INDEX))
    4   CONTINUE
        CALL SPFFTC(WORK,2*LY,-1)
        Y(0)=Y(0)+REAL(WORK(0))*AIMAG(WORK(0))/(TSV*NSGMTS)
        DO 5 M=1,LY
          P=AIMAG(WORK(M)*WORK(2*LY-M))
          Q=WORK(M)*CONJG(WORK(M))-WORK(2*LY-M)*CONJG(WORK(2*LY-M))
          Y(M)=Y(M)+CMPLX(0.5*P,0.25*Q)/(TSV*NSGMTS)
    5   CONTINUE
    6 CONTINUE
      IERROR=0
    7 RETURN
      END
C- 
C-******************************************************************
C-*                   CHAPTER 5 ROUTINES                           *
C-******************************************************************
C-
      COMPLEX FUNCTION SPGAIN(B,A,LB,LA,FREQ)
C-LATEST DATE: 02/20/87
C-THIS FUNCTION COMPUTES THE COMPLEX GAIN OF ANY CAUSAL LINEAR
C-SYSTEM IN DIRECT FORM.  FOR A PARALLEL SYSTEM, JUST TREAT EACH
C-SECTION AS DIRECT AND ADD THE RESULTS.  FOR A CASCADE SYSTEM,
C-TREAT EACH SECTION AS DIRECT AND MULTIPLY THE RESULTS TOGETHER.
C-YOU MUST SPECIFY:  DIMENSION B(0:LB),A(1:LA); COMPLEX GAIN.
C-THE LINEAR SYSTEM IS ASSUMED TO HAVE THE TRANSFER FUNCTION
C-
C-      B(0)+B(1)*Z**(-1)+B(2)*Z**(-2)+...+B(LB)*Z**(-LB)
C- H(Z)=-------------------------------------------------
C-      1.0+A(1)*Z**(-1)+A(2)*Z**(-2)+...+A(LA)*Z**(-LA)
C-
C-FOR AN FIR SYSTEM, USE LA=1 AND A(1)=0.  DO NOT USE LA=0.
C-FREQ=FREQUENCY IN HZ-S, I.E., SAMPLING FREQUENCY=1.0.
C-NOTE: COMPUTATION IS LIMITED BY "SMALL" AND "BIG" BELOW.
      DIMENSION B(0:LB),A(1:LA)
      COMPLEX Z1,BSUM,ASUM
      SMALL=1.E-10
      BIG=1.E10
      Z1=CEXP(CMPLX(0.,-8.*ATAN(1.)*FREQ))
      BSUM=0.
      IF(LB.LE.0) GO TO 2
      DO 1 I=LB,1,-1
        BSUM=(BSUM+B(I))*Z1
    1 CONTINUE
    2 ASUM=0.
      DO 3 I=LA,1,-1
        ASUM=(ASUM+A(I))*Z1
    3 CONTINUE
      IF(ABS(1.0+ASUM).LT.SMALL) SPGAIN=BIG
      IF(ABS(1.0+ASUM).GE.SMALL) SPGAIN=(B(0)+BSUM)/(1.0+ASUM)
      RETURN
      END
C-
      SUBROUTINE SPRESP(X,Y,LX,LY,B,A,LB,LA)
C-LATEST DATE: 11/13/85
C-TIME DOMAIN RESPONSE OF A CAUSAL LINEAR SYSTEM.
C-USER MUST DIMENSION X(0:LX),Y(0:LY),B(0:LB),A(1:LA)
C-X=USER-SUPPLIED INPUT SIGNAL WITH FIRST SAMPLE AT X(0).
C-THIS SIGNAL IS ASSUMED TO CONTINUE WITH ITS FINAL VALUE,
C- I.E., X(LX+1)=X(LX), ETC.  THUS A UNIT IMPULSE IS (1.,0.)
C- WITH LX=1, A UNIT STEP COULD BE (1.,1.) WITH LX=1, ETC.
C-Y(0) THRU Y(LY)=COMPUTED RESPONSE TO INPUT SIGNAL X.
C-B,A=COEFFICIENTS OF CAUSAL LINEAR SYSTEM WITH
C-
C-      B(0)+B(1)*Z**(-1)+B(2)*Z**(-2)+...+B(LB)*Z**(-LB)
C- H(Z)=-------------------------------------------------
C-      1.0+A(1)*Z**(-1)+A(2)*Z**(-2)+...+A(LA)*Z**(-LA)
C-
C-FOR AN FIR SYSTEM, USE LA=1 AND A(1)=0.  DO NOT USE LA=0.
C-NOTE: ZERO INITIAL CONDITIONS ARE ASSUMED.
      DIMENSION X(0:LX),Y(0:LY),B(0:LB),A(1:LA)
      DO 3 K=0,LY
        SUM=0.0
        DO 1 N=0,LB
          SAMPLE=0.0
          IF(K-N.GE.0) SAMPLE=X(MIN0(K-N,LX))
          SUM=SUM+B(N)*SAMPLE
    1   CONTINUE
        DO 2 N=1,LA
          SAMPLE=0.0
          IF(K-N.GE.0) SAMPLE=Y(K-N)
          SUM=SUM-A(N)*SAMPLE
    2   CONTINUE
        Y(K)=SUM
    3 CONTINUE
      RETURN
      END
C- 
C-***************************************************************
C-*                   CHAPTER 6 ROUTINES                        *
C-***************************************************************
C-
      SUBROUTINE SPFILT(B,A,LB,LA,X,N,PX,PY,IERROR)
C-LATEST DATE: 11/13/85
C-FILTERS N-POINT DATA SEQUENCE IN PLACE USING ARRAY X
C-TRANSFER FUNCTION COEFFICIENTS ARE IN ARRAYS B AND A
C-           B(0)+B(1)*Z**(-1)+.......+B(LB)*Z**(-LB)
C-    H(Z) = ----------------------------------------
C-             1+A(1)*Z**(-1)+.......+A(LA)*Z**(-LA)
C-PX SAVES PAST VALUES OF INPUT X
C-PY SAVES PAST VALUES OF OUTPUT Y
C-IERROR=0    NO ERRORS DETECTED
C-       1    FILTER RESPONSE EXCEEDS 1.E10
      DIMENSION X(0:N-1),B(0:LB),A(LA),PX(0:LB),PY(LA)
      IERROR=1
      DO 5 K=0,N-1
        PX(0)=X(K)
        X(K)=0.
        DO 1 L=0,LB
          X(K)=X(K)+B(L)*PX(L)
    1   CONTINUE
        DO 2 L=1,LA
          X(K)=X(K)-A(L)*PY(L)
    2   CONTINUE
        IF(ABS(X(K)).GT.1.E10) RETURN
        DO 3 L=LB,1,-1
          PX(L)=PX(L-1)
    3   CONTINUE
        DO 4 L=LA,2,-1
          PY(L)=PY(L-1)
    4   CONTINUE
        PY(1)=X(K)
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPFLTR(B,A,LB,LA,X,N,Y,PX,PY,IERROR)
C-LATEST DATE: 11/13/85
C-FILTERS N-POINT DATA SEQUENCE X AND RETURNS OUTPUT IN Y
C-TRANSFER FUNCTION COEFFICIENTS ARE IN ARRAYS B AND A
C-            B(0)+B(1)*Z**(-1)+........+B(LB)*Z**(-LB)
C-     H(Z) = -----------------------------------------
C-               1+A(1)*Z**(-1)+.......+A(LA)*Z**(-LA)
C-PX RETAINS PAST VALUES OF INPUT X
C-PY RETAINS PAST VALUES OF OUTPUT Y
C-IERROR=0     NO ERRORS DETECTED
C-       1     OUTPUT EXCEEDS 1.E10
C-NOTE: OUTPUT ARRAY Y MUST BE INITIALIZED BY CALLING PROGRAM
      DIMENSION X(0:N-1),B(0:LB),A(LA),Y(0:N-1),PX(0:LB),PY(LA)
      IERROR=1
      DO 5 K=0,N-1
        PX(0)=X(K)
        SUM=0.0
        DO 1 L=0,LB
          SUM=SUM+B(L)*PX(L)
    1   CONTINUE
        DO 2 L=1,LA
          SUM=SUM-A(L)*PY(L)
    2   CONTINUE
        IF(ABS(SUM).GT.1.E10) RETURN
        DO 3 L=LB,1,-1
          PX(L)=PX(L-1)
    3   CONTINUE
        DO 4 L=LA,2,-1
          PY(L)=PY(L-1)
    4   CONTINUE
        PY(1)=SUM
        Y(K)=Y(K)+SUM
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPCFLT(B,A,LS,NS,X,N,PX,PY,IERROR)
C-LATEST DATE: 11/13/85
C-FILTERS N-POINT DATA SEQUENCE IN PLACE USING ARRAY X
C-TRANSFER FUNCTION IS COMPOSED OF NS SECTIONS IN CASCADE WITH
C-      MTH STAGE TRANSFER FUNCTION
C-           B(0,M)+B(1,M)*Z**(-1)+......+B(LS,M)*Z**(-LS)
C-    H(Z) = -------------------------------------------
C-              1+A(1,M)*Z**(-1)+.......+A(LS,M)*Z**(-LS)
C-PX RETAINS PAST VALUES OF INPUT X
C-PY RETAINS PAST VALUES OF OUTPUT Y
C-IERROR=0    NO ERRORS DETECTED
C-    1 - NS  OUTPUT AT STAGE [IERROR] EXCEEDS 1.E10
      DIMENSION X(0:N-1),B(0:LS,NS),A(LS,NS),PX(0:LS,NS),PY(LS,NS)
      DO 5 M=1,NS
        IERROR=M
        DO 3 K=0,N-1
          PX(0,M)=X(K)
          X(K)=B(0,M)*PX(0,M)
          DO 1 LL=1,LS
            X(K)=X(K)+B(LL,M)*PX(LL,M)-A(LL,M)*PY(LL,M)
    1     CONTINUE
          IF(ABS(X(K)).GT.1.E10) RETURN
          DO 2 LL=LS,2,-1
            PX(LL,M)=PX(LL-1,M)
            PY(LL,M)=PY(LL-1,M)
    2     CONTINUE
          PX(1,M)=PX(0,M)
          PY(1,M)=X(K)
    3   CONTINUE
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPPFLT(B,A,LS,NS,X,N,Y,PX,PY,IERROR)
C-LATEST DATE: 11/13/85
C-FILTERS N-POINT DATA SEQUENCE X AND RETURNS OUTPUT IN Y
C-TRANSFER FUNCTION IS COMPOSED OF NS SECTIONS IN PARALLEL WITH
C-           MTH SECTION DEFINED BY
C-         B(0,M)+B(1,M)*Z**(-1)+........+B(LS,M)*Z**(-LS)
C-  H(Z) = ---------------------------------------------
C-            1+A(1,M)*Z**(-1)+.........+A(LS,M)*Z**(-LS)
C-PX RETAINS PAST VALUES OF INPUT X
C-PY RETAINS PAST VALUES OF OUTPUT Y
C-IERROR=0     NO ERRORS DETECTED
C-    1 - NS   OUTPUT AT STAGE [IERROR]  EXCEEDS 1.E10
      DIMENSION X(0:N-1),Y(0:N-1),B(0:LS,NS),A(LS,NS)
      DIMENSION PX(0:LS,NS),PY(LS,NS)
      DO 1 K=0,N-1
        Y(K)=0.0
    1 CONTINUE
      DO 5 M=1,NS
        IERROR=M
        DO 4 K=0,N-1
          PX(0,M)=X(K)
          SUM=B(0,M)*PX(0,M)
          DO 2 LL=1,LS
            SUM=SUM+B(LL,M)*PX(LL,M)-A(LL,M)*PY(LL,M)
    2     CONTINUE
          IF(ABS(SUM).GT.1.E10) RETURN
          DO 3 LL=LS,2,-1
            PX(LL,M)=PX(LL-1,M)
            PY(LL,M)=PY(LL-1,M)
    3     CONTINUE
          PX(1,M)=PX(0,M)
          PY(1,M)=SUM
          Y(K)=Y(K)+SUM
    4   CONTINUE
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPLFLT(KAPPA,NU,L,X,N,PAST,IERROR)
C-LATEST DATE: 11/13/85
C-FILTERS N-POINT DATA SEQUENCE IN PLACE USING ARRAY X
C-LATTICE TRANSFER FUNCTION COEFFICIENTS IN REAL ARRAYS KAPPA AND NU
C-PAST RETAINS OLD VALUES TO ENABLE BLOCK MODE FILTERING
C-IERROR=0    NO ERRORS DETECTED
C-       1    OUTPUT EXCEEDS 1.E10
      DIMENSION X(0:N-1),PAST(0:L)
      REAL KAPPA(0:L-1),NU(0:L)
      IERROR=1
      DO 5 K=0,N-1
        SUM=X(K)
        DO 2 LL=L,1,-1
          SUM=SUM-KAPPA(LL-1)*PAST(LL-1)
          PAST(LL)=PAST(LL-1)+KAPPA(LL-1)*SUM
    2   CONTINUE
        PAST(0)=SUM
        X(K)=0.0
        DO 3 LL=0,L
          X(K)=X(K)+NU(LL)*PAST(LL)
    3   CONTINUE
        IF(ABS(X(K)).GT.1.E10) RETURN
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPLTCF(B,A,L,KAPPA,NU,WORK,IERROR)
C-LATEST DATE: 11/13/85
C-CONVERTS TRANSFER FUNCTION COEFFICIENTS FROM DIRECT FORM TO LATTICE
C-DIRECT FORM H(Z) IS DEFINED BY
C-          B(0)+B(1)*Z**(-1)+...........+B(L)*Z**(-L)
C-   H(Z) = ------------------------------------------
C-            1+A(1)*Z**(-1)+..........+A(L)*Z**(-L)
C-LATTICE COEF ARE RETURNED IN REAL ARRAYS KAPPA AND NU
C-IERROR=0     CONVERSION WITH NO ERRORS DETECTED
C-       1     UNSTABLE H(Z)
C-WORK ARRAY IS USED INTERNALLY.
      DIMENSION B(0:L),A(L),WORK(0:L,2)
      REAL KAPPA(0:L-1),NU(0:L)
      IERROR=1
      WORK(0,1)=1.
      DO 1 LL=1,L
        WORK(LL,1)=A(LL)
    1 CONTINUE
      DO 5 LL=L,1,-1
        DO 2 J=0,LL
          WORK(J,2)=WORK(LL-J,1)
    2   CONTINUE
        KAPPA(LL-1)=WORK(LL,1)
        IF(ABS(KAPPA(LL-1)).GE.1.0) RETURN
        DO 3 J=0,LL
          WORK(J,1)=(WORK(J,1)-KAPPA(LL-1)*WORK(J,2))/
     +                    (1.-KAPPA(LL-1)**2)
    3   CONTINUE
        NU(LL)=B(LL)
        DO 4 J=0,LL
          B(J)=B(J)-NU(LL)*WORK(J,2)
    4   CONTINUE
    5 CONTINUE
      NU(0)=B(0)
      IERROR=0
      RETURN
      END
C- 
C-*********************************************************************
C-*                   CHAPTER 7 ROUTINES                              *
C-*********************************************************************
C-
      SUBROUTINE SPBILN(D,C,LN,B,A,WORK,IERROR)
C-LATEST DATE: 11/13/85
C-CONVERTS ANALOG H(S) TO DIGITAL H(Z) VIA BILINEAR TRANSFORM
C-     ANALOG TRANSFER FUNCTION         DIGITAL TRANSFER FUNCTION
C-         D(L)*S**L+.....+D(0)             B(0)+......+B(L)*Z**-L
C-   H(S)=---------------------        H(Z)=----------------------
C-         C(L)*S**L+.....+C(0)               1+.......+A(L)*Z**-L
C-H(S) IS ASSUMED TO BE PRE-SCALED AND PRE-WARPED
C-LN SPECIFIES THE LENGTH OF THE COEFFICIENT ARRAYS
C-FILTER ORDER L IS COMPUTED INTERNALLY
C-WORK IS AN INTERNAL ARRAY (2D) SIZED TO MATCH COEF ARRAYS
C-IERROR=0    NO ERRORS DETECTED IN TRANSFORMATION
C-       1    ALL ZERO TRANSFER FUNCTION
C-       2    INVALID TRANSFER FUNCTION; Y(K) COEF=0
      DIMENSION D(0:LN),C(0:LN),B(0:LN),A(LN),WORK(0:LN,0:LN)
      DO 1 I=LN,0,-1
        IF(C(I).NE.0..OR.D(I).NE.0.)GO TO 2
    1 CONTINUE
      IERROR=1
      RETURN
    2 L=I
      DO 5 J=0,L
        WORK(0,J)=1.
    5 CONTINUE
      TMP=1.
      DO 6 I=1,L
        TMP=TMP*FLOAT(L-I+1)/FLOAT(I)
        WORK(I,0)=TMP
    6 CONTINUE
      DO 8 I=1,L
        DO 7 J=1,L
          WORK(I,J)=WORK(I,J-1)-WORK(I-1,J)-WORK(I-1,J-1)
    7   CONTINUE
    8 CONTINUE
      DO 10 I=L,0,-1
        B(I)=0.
        ATMP=0.
        DO 9 J=0,L
          B(I)=B(I)+WORK(I,J)*D(J)
          ATMP=ATMP+WORK(I,J)*C(J)
    9   CONTINUE
        SCALE=ATMP
        IF(I.NE.0) A(I)=ATMP
   10 CONTINUE
      IERROR=2
      IF(SCALE.EQ.0.) RETURN
      B(0)=B(0)/SCALE
      DO 12 I=1,L
        B(I)=B(I)/SCALE
        A(I)=A(I)/SCALE
   12 CONTINUE
      DO 14 I=L+1,LN
        B(I)=0.0
        A(I)=0.0
   14 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPFBLT(D,C,LN,IBAND,FLN,FHN,B,A,WORK,IERROR)
C-LATEST DATE: 05/19/86
C-CONVERTS NORMALIZED LP ANALOG H(S) TO DIGITAL H(Z)
C-      ANALOG TRANSFER FUNCTION           DIGITAL TRANSFER FUNCTION
C-       D(M)*S**M+.....+D(0)               B(0)+.....+B(L)*Z**-L
C-  H(S)=--------------------          H(Z)=--------------------
C-       C(M)*S**M+.....+C(0)                 1+......+A(L)*Z**-L
C-FILTER ORDER L IS COMPUTED INTERNALLY
C-IBAND=1    LOWPASS            FLN=NORMALIZED CUTOFF IN HZ-SEC
C-      2    HIGHPASS           FLN=NORMALIZED CUTOFF IN HZ-SEC
C-      3    BANDPASS           FLN=LOW CUTOFF; FHN=HIGH CUTOFF
C-      4    BANDSTOP           FLN=LOW CUTOFF; FHN=HIGH CUTOFF
C-LN SPECIFIES COEFFICIENT ARRAY SIZE
C-WORK(0:LN,0:LN) IS A WORK ARRAY USED INTERNALLY
C-RETURN IERROR=0    NO ERRORS DETECTED
C-              1    ALL ZERO TRANSFER FUNCTION
C-              2    BILIN: INVALID TRANSFER FUNCTION
C-              3    FILTER ORDER EXCEEDS ARRAY SIZE
C-              4    INVALID FILTER TYPE PARAMETER (IBAND)
C-              5    INVALID CUTOFF FREQUENCY
      DIMENSION D(0:LN),C(0:LN),B(0:LN),A(LN),WORK(0:LN,0:LN)
      PI=4.*ATAN(1.)
      IERROR=0
      IF(IBAND.LT.1.OR.IBAND.GT.4) IERROR=4
      IF(FLN.LE.0..OR.FLN.GT.0.5) IERROR=5
      IF(IBAND.GE.3.AND.FLN.GE.FHN) IERROR=5
      IF(IBAND.GE.3.AND.FHN.GT.0.5) IERROR=5
      IF(IERROR.NE.0) RETURN
      DO 1 I=LN,0,-1
        IF(C(I).NE.0..OR.D(I).NE.0.) GO TO 2
    1 CONTINUE
      IERROR=1
      RETURN
    2 M=I
      W1=TAN(PI*FLN)
      L=M
      IF(IBAND.LE.2) GO TO 3
      L=2*M
      W2=TAN(PI*FHN)
      W=W2-W1
      W02=W1*W2
    3 CONTINUE
      IERROR=3
      IF(L.GT.LN) RETURN
      GO TO (30,20,40,20) IBAND
C-SUBSTITUTION OF 1/S TO GENERATE HIGHPASS (HP,BS)
   20 CONTINUE
      DO 25 MM=0,M/2
        TMP=D(MM)
        D(MM)=D(M-MM)
        D(M-MM)=TMP
        TMP=C(MM)
        C(MM)=C(M-MM)
        C(M-MM)=TMP
   25 CONTINUE
      IF(IBAND.EQ.4) GO TO 40
C-SCALING S/W1 FOR LOWPASS,HIGHPASS
   30 CONTINUE
      DO 35 MM=0,M
        D(MM)=D(MM)/(W1**MM)
        C(MM)=C(MM)/(W1**MM)
   35 CONTINUE
      GO TO 100
C-SUBSTITUTION OF (S**2+W0**2)/(W*S)  BANDPASS,BANDSTOP
   40 CONTINUE
      DO 45 LL=0,L
        WORK(LL,0)=0.
        WORK(LL,1)=0.
   45 CONTINUE
      DO 52 MM=0,M
        TMPD=D(MM)*(W**(M-MM))
        TMPC=C(MM)*(W**(M-MM))
        DO 50 K=0,MM
          LS=M+MM-2*K
          TMP=SPBFCT(MM,MM)/(SPBFCT(K,K)*SPBFCT(MM-K,MM-K))
          WORK(LS,0)=WORK(LS,0)+TMPD*(W02**K)*TMP
          WORK(LS,1)=WORK(LS,1)+TMPC*(W02**K)*TMP
   50   CONTINUE
   52 CONTINUE
      DO 55 LL=0,L
        D(LL)=WORK(LL,0)
        C(LL)=WORK(LL,1)
   55 CONTINUE
C-SUBSTITUTE (Z-1)/(Z+1)
  100 CONTINUE
      CALL SPBILN(D,C,LN,B,A,WORK,IERROR)
      RETURN
      END
C-
      SUBROUTINE SPBWCF(L,K,LN,D,C,IERROR)
C-LATEST DATE: 11/13/85
C-GENERATES KTH SECTION COEFFICIENTS FOR LTH ORDER NORMALIZED
C-      LOWPASS BUTTERWORTH FILTER
C-SECOND ORDER SECTIONS: K<=(L+1)/2
C-ODD ORDER L:  FINAL SECTION WILL CONTAIN 1ST ORDER POLE
C-LN DEFINES COEFFICIENT ARRAY SIZE
C-ANALOG COEFFICIENTS ARE RETURNED IN D AND C
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID FILTER ORDER L
C-       2      INVALID SECTION NUMBER K
      DIMENSION D(0:LN),C(0:LN)
      PI=4.*ATAN(1.)
      IERROR=0
      IF(L.LE.0) IERROR=1
      IF(K.LE.0.OR.K.GT.INT((L+1)/2)) IERROR=2
      IF(IERROR.NE.0) RETURN
      D(0)=1.
      C(0)=1.
      DO 1 I=1,LN
        D(I)=0.
        C(I)=0.
    1 CONTINUE
      TMP=K-(L+1.)/2.
      IF(TMP.EQ.0.) THEN
        C(1)=1.
      ELSE
        C(1)=(-2.)*COS((2*K+L-1)*PI/(2*L))
        C(2)=1.
      ENDIF
      RETURN
      END
C-
      SUBROUTINE SPCHBI(L,K,LN,EP,D,C,IERROR)
C-LATEST DATE: 11/13/85
C-GENERATES KTH SECTION COEFFICIENTS FOR LTH ORDER NORMALIZED
C-            LOWPASS CHEBYSHEV TYPE I ANALOG FILTER
C-SECOND ORDER SECTIONS:  K<=(L+1)/2
C-ODD ORDER L: LAST SECTION WILL CONTAIN SINGLE POLE
C-LN DEFINES COEFFICIENT ARRAY SIZE
C-EP REGULATES THE PASSBAND RIPPLE
C-TRANSFER FUNCTION SCALING IS INCLUDED IN FIRST SECTION (L EVEN)
C-ANALOG COEFFICIENTS ARE RETURNED IN D AND C
C-IERROR=0    NO ERRORS DETECTED
C-       1    INVALID FILTER ORDER L
C-       2    INVALID SECTION NUMBER K
C-       3    INVALID RIPPLE PARAMETER EP
      DIMENSION D(0:LN),C(0:LN)
      PI=4.*ATAN(1.)
      IERROR=0
      IF(L.LE.0) IERROR=1
      IF(K.GT.INT((L+1)/2).OR.K.LE.0) IERROR=2
      IF(EP.LE.0.) IERROR=3
      IF(IERROR.NE.0) RETURN
      GAM=((1.+SQRT(1.+EP**2))/EP)**(1./L)
      SIGMA=.5*(1./GAM-GAM)*SIN((2*K-1)*PI/(2*L))
      OMEGA=.5*(GAM+1./GAM)*COS((2*K-1)*PI/(2*L))
      DO 1 LL=0,LN
        D(LL)=0.
        C(LL)=0.
    1 CONTINUE
      IF(INT(L/2).NE.INT((L+1)/2).AND.K.EQ.(L+1)/2) THEN
        D(0)=-1.*SIGMA
        C(0)=D(0)
        C(1)=1.
        RETURN
      ENDIF
      C(0)=SIGMA**2+OMEGA**2
      C(1)=-2.*SIGMA
      C(2)=1.
      D(0)=C(0)
      IF(INT(L/2).EQ.INT((L+1)/2).AND.K.EQ.1) D(0)=D(0)/SQRT(1.+EP**2)
      RETURN
      END
C-
      SUBROUTINE SPCBII(L,K,LN,WS,ATT,D,C,IERROR)
C-LATEST DATE: 11/13/85
C-GENERATES KTH SECTION COEFFICIENTS FOR LTH ORDER NORMALIZED
C-      LOWPASS CHEBYSHEV TYPE II ANALOG FILTER
C-SECOND ORDER SECTIONS:  K<= (L+1)/2
C-ODD ORDER L:  FINAL SECTION WILL CONTAIN SINGLE POLE
C-LN DEFINES COEFFICIENT ARRAY SIZE
C-WS AND ATT REGULATE STOPBAND ATTENUATION
C-      MAGNITUDE WILL BE 1/ATT AT WS RAD/SEC
C-ANALOG COEFFICIENTS ARE RETURNED IN ARRAYS D AND C
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID FILTER ORDER L
C-       2      INVALID SECTION NUMBER K
C-       3      INVALID STOPBAND FREQUENCY WS
C-       4      INVALID ATTENUATION PARAMETER
      DIMENSION D(0:LN),C(0:LN)
      PI=4.*ATAN(1.)
      IERROR=0
      IF(L.LE.0) IERROR=1
      IF(K.GT.INT((L+1)/2).OR.K.LT.1) IERROR=2
      IF(WS.LE.1.) IERROR=3
      IF(ATT.LE.0.) IERROR=4
      IF(IERROR.NE.0) RETURN
      GAM=(ATT+SQRT(ATT**2-1.))**(1./L)
      ALPHA=.5*(1./GAM-GAM)*SIN((2*K-1)*PI/(2*L))
      BETA=.5*(GAM+1./GAM)*COS((2*K-1)*PI/(2*L))
      SIGMA=(WS*ALPHA)/(ALPHA**2+BETA**2)
      OMEGA=(-1.*WS*BETA)/(ALPHA**2+BETA**2)
      DO 1 LL=0,LN
        D(LL)=0.
        C(LL)=0.
    1 CONTINUE
      IF(INT(L/2).NE.INT((L+1)/2).AND.K.EQ.(L+1)/2) THEN
        D(0)=-1.*SIGMA
        C(0)=D(0)
        C(1)=1.
        RETURN
      ENDIF
      SCLN=SIGMA**2+OMEGA**2
      SCLD=(WS/COS((2*K-1)*PI/(2*L)))**2
      D(0)=SCLN*SCLD
      D(2)=SCLN
      C(0)=D(0)
      C(1)=-2.*SIGMA*SCLD
      C(2)=SCLD
      RETURN
      END
C-
      SUBROUTINE SPBSSL(L,WSCL,LN,D,C,IERROR)
C-LATEST DATE: 11/13/85
C-GENERATES ANALOG FILTER COEFFICIENTS FOR LTH ORDER
C-      NORMALIZED LOWPASS BESSEL FILTER
C-COEFFICIENTS ARE RETURNED IN ARRAYS D AND C
C-LN SPECIFIES ARRAY SIZE (LN>=L)
C-WSCL CONTROLS FREQUENCY SCALING SUCH THAT RESPONSE AT 1 RAD/SEC
C-      IS EQUAL TO THAT OF UNSCALED H(S) AT WSCL RAD/SEC
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID FILTER ORDER (L<=0 OR L>=LN)
C-       2      INVALID SCALE PARAMETER (WSCL<=0)
      DIMENSION D(0:LN),C(0:LN)
      IERROR=0
      IF(L.LE.0.OR.L.GT.LN) IERROR=1
      IF(WSCL.LE.0.) IERROR=2
      IF(IERROR.NE.0) RETURN
      DO 1 LL=0,LN
        D(LL)=0.
        C(LL)=0.
    1 CONTINUE
      DO 2 K=0,L
        DENOM=(2**(L-K))*SPBFCT(K,K)*SPBFCT(L-K,L-K)
        C(K)=(WSCL**K)*SPBFCT(2*L-K,2*L-K)/DENOM
    2 CONTINUE
      D(0)=C(0)
      RETURN
      END
C-
      SUBROUTINE SPIIRD(IFILT,IBAND,NS,LS,F1,F2,F3,F4,DB,B,A,IERROR)
C-LATEST DATE: 09/25/86
C-IIR LOWPASS, HIGHPASS, BANDPASS, AND BANDSTOP DESIGN OF CHEBYSHEV 1,
C-  CHEBYSHEV 2, AND BUTTERWORTH DIGITAL FILTERS IN CASCADE FORM.
C-IFILT=1(CHEB1-PASSBAND RIPPLE), 2(CHEB2-STOPBAND RIPPLE), OR 
C-      3(BUTTERWORTH-NO RIPPLE).
C-IBAND=1(LOWPASS), 2(HIGHPASS), 3(BANDPASS), OR 4(BANDSTOP).
C-NS   =NUMBER OF SECTIONS IN CASCADE.
C-LS   =ORDER OF EACH SECTION: USUALLY 2(IBAND=1,2) OR 4(IBAND=3,4).
C-F1-F4=FREQ. IN HZ-SEC. (SAMPLING FREQ.=1.0) AS IN PLOTS BELOW.
C
C     LOWPASS        HIGHPASS       BANDPASS        BANDSTOP
C
C         F  F         F  F           F F  F F        F F F F
C         1  2         1  2           1 2  3 4        1 2 3 4
C   0 XXX-------   0 +------XXX   0 +----XX----   0 XX--------X
C     I X .  .       I .  . X       I . .XX. .      IX. . . .X
C     I  X.  .       I .  .X        I . .XX. .      IX. . . .X
C     I...X  .       I....X         I...X..X .      I.X.....X
C     I    X .       I . X          I . X  X .      I  X. .X
C     I     X.       I .X           I .X    X.      I  X. .X
C  DB I......X    DB I.X         DB I.X......X   DB I...XXX
C     I       X      IX             IX        X     I
C
C-      F3 AND F4 ARE NOT USED WITH ANY LOW OR HIGHPASS.
C-      F2 IS NOT USED WITH LOWPASS BUTTERWORTH.
C-      F1 IS NOT USED WITH HIGHPASS BUTTERWORTH.
C-      F1 AND F4 ARE NOT USED WITH BANDPASS BUTTERWORTH.
C-      F2 AND F3 ARE NOT USED WITH BANDSTOP BUTTERWORTH.
C
C-DB   =DB OF STOPBAND REJECTION.  APPLIES TO CHEB. FILTERS ONLY.
C-      NOT USED WITH BUTTERWORTH.  MUST BE GREATER THAT 3 DB.
C-B    =NUMERATOR COEFFICIENTS, ALWAYS DIMENSIONED B(0:LS,NS).
C-A    =DENOMINATOR COEFFICIENTS, ALWAYS DIMENSIONED A(LS,NS).
C-IERROR=0    NO ERRORS.
C-       1-5  SEE SPFBLT ERROR LIST.
C-       6    IFILT OR IBAND OUT OF RANGE.
C-       7    F1-F4 NOT IN SEQUENCE OR NOT BETWEEN O.O AND 0.5,
C-            OR DB NOT GREATER THAN 3.
C-       11+  SEE SPCHBI, SPCBII, OR SPBWCF ERROR LIST.
C-
      DIMENSION B(0:LS,NS),A(LS,NS),D(0:4),C(0:4),WORK(0:4,0:4)
      COSH(X)=0.5*(EXP(X)+EXP(-X))
      COSH1(X)=ALOG(X+SQRT(X*X-1.))
      WARP(F)=TAN(PI*F)
      BPSUB(OM)=(OM*OM-WARP(FH)*WARP(FL))/((WARP(FH)-WARP(FL))*OM)
      OMIN(OM1,OM2)=MIN(ABS(OM1),ABS(OM2))
      PI=4.*ATAN(1.)
      IERROR=6
      IF(0.GE.NS) RETURN
      IF(IFILT.LT.1.OR.IFILT.GT.3) RETURN
      IF(IBAND.LT.1.OR.IBAND.GT.4) RETURN
      IERROR=7
      IF(IBAND.EQ.1.OR.IBAND.EQ.4) FL=F1
      IF(IBAND.EQ.2.OR.IBAND.EQ.3) FL=F2
      IF(IBAND.LE.3) FH=F3
      IF(IBAND.EQ.4) FH=F4
      IF(IBAND.LT.3) THEN
        IF(IFILT.LT.3.AND.(0.0.GE.F1.OR.F1.GE.F2.OR.F2.GE.0.5)) RETURN
        IF(IFILT.EQ.3.AND.(0.0.GE.FL.OR.FL.GE.0.5)) RETURN
      ELSEIF(IFILT.LT.3) THEN
        IF(0.0.GE.F1.OR.F1.GE.F2.OR.F2.GE.F3) RETURN
        IF(F3.GE.F4.OR.F4.GE.0.5) RETURN
      ELSEIF(IFILT.EQ.3) THEN
        IF(0.0.GE.FL.OR.FL.GE.FH.OR.FH.GE.0.5) RETURN
      ENDIF
      IF(IFILT.LT.3.AND.DB.LE.3.) RETURN
      IF(IFILT.LT.3) THEN
        IF(IBAND.LE.2) OMEGA=WARP(F2)/WARP(F1)
        IF(IBAND.EQ.3) OMEGA=OMIN(BPSUB(WARP(F1)),BPSUB(WARP(F4)))
        IF(IBAND.EQ.4) OMEGA=OMIN(1./BPSUB(WARP(F2)),1./BPSUB(WARP(F3)))
        ALAMDA=10.**(DB/20.)
        EPSLON=ALAMDA/COSH(2*NS*COSH1(OMEGA))
      ENDIF
      DO 1 K=1,NS
        IF(IFILT.EQ.1) CALL SPCHBI(2*NS,K,4,EPSLON,D,C,IERROR)
        IF(IFILT.EQ.2) CALL SPCBII(2*NS,K,4,OMEGA,ALAMDA,D,C,IERROR)
        IF(IFILT.EQ.3) CALL SPBWCF(2*NS,K,4,D,C,IERROR)
        IF(IERROR.NE.0) THEN
          IERROR=10*IFILT+IERROR
          RETURN
        ENDIF
        CALL SPFBLT(D,C,LS,IBAND,FL,FH,B(0,K),A(1,K),WORK,IERROR)
        IF(IERROR.NE.0) RETURN
    1 CONTINUE
      RETURN
      END
C- 
C-*********************************************************************
C-*                   CHAPTER 8 ROUTINES                              *
C-*********************************************************************
C-
      SUBROUTINE SPFIRL(L,FCN,IWNDO,B,IERROR)
C-LATEST DATE: 05/17/86
C-FIR LOWPASS FILTER DESIGN USING WINDOWED FOURIER SERIES
C-L=FILTER LENGTH = L+1
C-FCN=NORMALIZED CUT-OFF FREQUENCY IN HERTZ-SECONDS
C-IWNDO=WINDOW USED TO TRUNCATE FOURIER SERIES
C-        1-RECTANGULAR; 2-TAPERED RECTANGULAR; 3-TRIANGULAR
C-        4-HANNING; 5-HAMMING; 6-BLACKMAN
C-B(0:L)=DIGITAL FILTER COEFFICIENTS RETURNED
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID FILTER LENGTH (L<=0)
C-       2      INVALID WINDOW TYPE IWNDO
C-       3      INVALID CUT-OFF FCN; <=0 OR >=0.5
      DIMENSION B(0:L)
      IERROR=0
      IF(L.LE.0) IERROR=1
      IF(IWNDO.LT.1.OR.IWNDO.GT.6) IERROR=2
      IF(FCN.LE.0..OR.FCN.GE.0.5) IERROR=3
      IF(IERROR.NE.0) RETURN
      DO 1 I=0,L
        B(I)=0.0
    1 CONTINUE
      PI=4.*ATAN(1.)
      WCN=2.*PI*FCN
      DLY=L/2.
      LIM=INT(L/2)
      IF(DLY.EQ.L/2) THEN
        LIM=LIM-1
        B(L/2)=WCN/PI
      ENDIF
      DO 2 I=0,LIM
        B(I)=((SIN(WCN*(I-DLY)))/(PI*(I-DLY)))*SPWNDO(IWNDO,L+1,I)
        B(L-I)=B(I)
    2 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPFIRD(L,IBAND,FLN,FHN,IWNDO,B,IERROR)
C-LATEST DATE: 05/18/86
C-FIR DIGITAL FILTER DESIGN USING WINDOWED FOURIER SERIES
C-L=LENGTH OF FILTER = L+1
C-IBAND=1(LOWPASS); 2(HIGHPASS); 3(BANDPASS); 4(BANDSTOP)
C-FLN=NORMALIZED LOW CUT-OFF FREQUENCY IN HZ-SEC
C-FHN=NORMALIZED HIGH CUT-OFF (BP,BS) IN HZ-SEC
C-IWNDO=1(RECTANGULAR); 2(TAPERED RECTANGULAR); 3(TRIANGULAR)
C-      4(HANNING); 5(HAMMING); 6(BLACKMAN)
C-DIGITAL FILTER COEFFICIENTS ARE RETURNED IN B(0:L)
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID LENGTH  (L<=0)
C-       2      INVALID WINDOW TYPE
C-       3      INVALID FILTER TYPE
C-       4      INVALID CUT-OFF FREQUENCY
      DIMENSION B(0:L)
      PI=4.*ATAN(1.)
      DO 1 I=0,L
        B(I)=0.
    1 CONTINUE
      IERROR=0
      IF(L.LE.0) IERROR=1
      IF(IWNDO.LT.1.OR.IWNDO.GT.6) IERROR=2
      IF(IBAND.LT.1.OR.IBAND.GT.4) IERROR=3
      IF(FLN.LE.0..OR.FLN.GT.0.5) IERROR=4
      IF(IBAND.GE.3.AND.FLN.GE.FHN) IERROR=4
      IF(IBAND.GE.3.AND.FHN.GE.0.5) IERROR=4
      IF(IERROR.NE.0) RETURN
      DLY=L/2.
      LIM=INT(L/2)
      MID=0
      IF(DLY.EQ.LIM) THEN
        LIM=LIM-1
        MID=1
      ENDIF
      WC1=2.*PI*FLN
      IF(IBAND.GE.3) WC2=2.*PI*FHN
      GO TO (5,10,15,20) IBAND
C-LOWPASS DESIGN
    5 CONTINUE
      DO 6 I=0,LIM
        S=I-DLY
        B(I)=((SIN(WC1*S))/(PI*S))*SPWNDO(IWNDO,L+1,I)
        B(L-I)=B(I)
    6 CONTINUE
      IF(MID.EQ.1) B(L/2)=WC1/PI
      RETURN
C-HIGHPASS DESIGN
   10 CONTINUE
      DO 11 I=0,LIM
        S=I-DLY
        B(I)=((SIN(PI*S)-SIN(WC1*S))/(PI*S))*SPWNDO(IWNDO,L+1,I)
        B(L-I)=B(I)
   11 CONTINUE
      IF(MID.EQ.1) B(L/2)=1.-WC1/PI
      RETURN
C-BANDPASS DESIGN
   15 CONTINUE
      DO 16 I=0,LIM
        S=I-DLY
        B(I)=((SIN(WC2*S)-SIN(WC1*S))/(PI*S))*SPWNDO(IWNDO,L+1,I)
        B(L-I)=B(I)
   16 CONTINUE
      IF(MID.EQ.1) B(L/2)=(WC2-WC1)/PI
      RETURN
C-BANDSTOP DESIGN
   20 CONTINUE
      DO 21 I=0,LIM
        S=I-DLY
        B(I)=((SIN(WC1*S)+SIN(PI*S)-SIN(WC2*S))/(PI*S))*
     +         SPWNDO(IWNDO,L+1,I)
        B(L-I)=B(I)
   21 CONTINUE
      IF(MID.EQ.1) B(L/2)=(WC1+PI-WC2)/PI
      RETURN
      END
C- 
C-*********************************************************************
C-*                   CHAPTER 9 ROUTINES                              *
C-*********************************************************************
C-
      SUBROUTINE SPCONV(X,Y,L,NMIN,IERROR)
C-LATEST DATE: 11/27/85
C-FAST CONVOLUTION OF SEQUENCES X AND Y.
C-X AND Y SHOULD BE DIFFERENT VECTORS, DIMENSIONED X(0:L) AND Y(0:L).
C-L=LAST INDEX IN BOTH X AND Y.  MUST BE (POWER OF 2)+1 AND AT LEAST 5.
C-NMIN=MINIMUM SHIFT OF INTEREST IN THE CONVOLUTION FUNCTION.
C-FFT LENGTH ,N, USED INTERNALLY, IS L-1.
C-LET K=INDEX OF LAST NONZERO SAMPLE IN Y(0)---Y(N-1).  THEN X(0)
C- THRU X(N-1) MUST INCLUDE PADDING OF AT LEAST K-NMIN-1 ZEROS.
C-CONVOLUTION FUNCTION (OUTPUT) REPLACES X(NMIN) THRU X(N-1).
C-IERROR=0  NO ERROR DETECTED
C-       1  L-1 NOT A POWER OF 2
C-       2  NMIN OUT OF RANGE
C-       3  INADEQUATE ZERO PADDING
      DIMENSION X(0:L),Y(0:L)
      COMPLEX CX
      IERROR=1
      N=L-1
      TEST=N
    1 TEST=TEST/2.
      IF(TEST-2.) 8,2,1
    2 IERROR=2
      IF(NMIN.LT.0.OR.NMIN.GE.N) RETURN
      IERROR=3
      DO 3 K=N-1,0,-1
        IF(Y(K).NE.0.) GO TO 4
    3 CONTINUE
    4 DO 5 J=N-1,0,-1
        IF(X(J).NE.0.) GO TO 6
    5 CONTINUE
    6 IF(N-J.LE.K-NMIN) RETURN
      CALL SPFFTR(X,N)
      CALL SPFFTR(Y,N)
      DO 7 M=0,N/2
        CX=CMPLX(X(2*M),X(2*M+1))*CMPLX(Y(2*M),Y(2*M+1))
        X(2*M)=REAL(CX)/N
        X(2*M+1)=AIMAG(CX)/N
    7 CONTINUE
      CALL SPIFTR(X,N)
      IERROR=0
    8 RETURN
      END
C-
      SUBROUTINE SPCORR(X,Y,L,ITYPE,NMAX,IERROR)
C-LATEST DATE: 09/18/86
C-FAST CORRELATION OF X(0:L) AND Y(0:L).  FINDS RXY(0) THRU RXY(NMAX).
C-L=LAST INDEX IN BOTH X AND Y.  MUST BE (POWER OF 2)+1 AND AT LEAST 5.
C-ITYPE=TYPE OF CORRELATION=0 IF X AND Y ARE THE SAME VECTOR (AUTO-
C-        CORRELATION), OR NOT 0 IF X AND Y ARE DIFFERENT VECTORS.
C-NMAX=MAXIMUM LAG OF INTEREST IN THE CORRELATION FUNCTION.
C-FFT LENGTH ,N, USED INTERNALLY, IS L-1.
C-LET K=INDEX OF FIRST NONZERO SAMPLE IN Y(0)---Y(N-1).  THEN X(0)
C- THRU X(N-1) MUST INCLUDE PADDING OF AT LEAST NMAX-K ZEROS.
C-CORRELATION FUNCTION, RXY, REPLACES X(0) THRU X(NMAX).
C-Y(0) THRU Y(L) IS REPLACED BY ITS FFT, COMPUTED USING SPFFTR.
C-IERROR=0  NO ERROR DETECTED
C-       1  L-1 NOT A POWER OF 2
C-       2  NMAX OUT OF RANGE
C-       3  INADEQUATE ZERO PADDING
      DIMENSION X(0:L),Y(0:L)
      COMPLEX CX
      IERROR=1
      N=L-1
      TEST=N
    1 TEST=TEST/2.
      IF(TEST-2.) 8,2,1
    2 IERROR=2
      IF(NMAX.LT.0.OR.NMAX.GE.N) RETURN
      IERROR=3
      DO 3 K=0,N-1
        IF(Y(K).NE.0.) GO TO 4
    3 CONTINUE
    4 DO 5 J=N-1,0,-1
        IF(X(J).NE.0.) GO TO 6
    5 CONTINUE
    6 IF(N-1-J.LT.NMAX-K) RETURN
      CALL SPFFTR(X,N)
      IF(ITYPE.NE.0) CALL SPFFTR(Y,N)
      DO 7 M=0,N/2
        CX=CMPLX(X(2*M),-X(2*M+1))*CMPLX(Y(2*M),Y(2*M+1))
        X(2*M)=REAL(CX)/N
        X(2*M+1)=AIMAG(CX)/N
    7 CONTINUE
      CALL SPIFTR(X,N)
      IERROR=0
    8 RETURN
      END
C-  
C-******************************************************************
C-*                   CHAPTER 10 ROUTINES                          *
C-******************************************************************
C-
      SUBROUTINE SPDECI(X,LX,RATIO,LX2,IERROR)
C-LATEST DATE: 11/20/85
C-LINEAR DECIMATION OF A SEQUENCE OF EQUALLY-SPACED SAMPLES.
C-X(0:LX)=ORIGINAL DATA VECTOR WITH STEP SIZE T1, TO BE INCREASED
C-        TO T2.
C-LX=LAST INDEX OF ORIGINAL SEQUENCE, X(0) --- X(LX). (INPUT.)
C-RATIO=T2/T1=STEP SIZE RATIO.  MUST BE GE 1.0 AND LE LX.  (INPUT.)
C-LX2=LAST INDEX OF DECIMATED SEQUENCE=LX/RATIO.  (OUTPUT.)
C-IERROR=0 IF NO ERROR DETECTED, 1 IF RATIO IS OUT OF RANGE.
C-COMPUTATION IS IN PLACE.  NEW SEQUENCE REPLACES X(0) THROUGH X(LX2).
C-THE REMAINING ELEMENTS IN X, X(LX2+1) THROUGH X(LX), ARE SET TO ZEROS.
      DIMENSION X(0:LX)
      IERROR=1
      IF(RATIO.LT.1.0.OR.RATIO.GT.FLOAT(LX)) RETURN
      LX2=LX/RATIO
      DO 1 K=1,LX
        K1=K*RATIO
        IF(K.LE.LX2) X(K)=X(K1)+(K*RATIO-K1)*(X(K1+1)-X(K1))
        IF(K.GT.LX2) X(K)=0.
    1 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPLINT(X,LX,LX1,RATIO,LX2,IERROR)
C-LATEST DATE: 11/20/85
C-LINEAR INTERPOLATION BETWEEN EQUALLY SPACED SAMPLES.
C-X(0:LX)=VECTOR CONTAINING THE ORIGINAL DATA VECTOR, X(0:LX1) WITH
C-        STEP SIZE T1, TO BE INTERPOLATED.
C-LX1=LAST INDEX OF INPUT SEQUENCE, X(0) --- X(LX1).  (INPUT.)
C-RATIO=T2/T1=STEP SIZE RATIO.  MUST BE GT 0.0 AND LT 1.0.  (INPUT.)
C-LX2=LAST INDEX IN INTERPOLATED SEQUENCE=LX1/RATIO.  (OUTPUT.)
C-IERROR=0  NO ERROR DETECTED
C-       1  RATIO OUT OF RANGE
C-       2  LX TOO SMALL FOR INTERPOLATED RESULT
C-COMPUTATION IS IN PLACE.  LX MUST BE AT LEAST LX2=LX1/RATIO.
C-THE REMAINING ELEMENTS, X(LX2+1) --- X(LX), ARE SET TO ZERO.
      DIMENSION X(0:LX)
      IERROR=1
      IF(RATIO.LE.0.0.OR.RATIO.GE.1.0) RETURN
      IERROR=2
      LX2=LX1/RATIO
      IF(LX2.GT.LX) RETURN
      DO 1 K=LX,1,-1
        IX=K*RATIO
        IF(K.LE.LX2) X(K)=X(IX)+(K*RATIO-IX)*(X(IX+1)-X(IX))
        IF(K.GT.LX2) X(K)=0.
    1 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPZINT(X,LX,LX1,RATIO,LX2,IERROR)
C-LATEST DATE: 11/27/85
C-INTERPOLATION BETWEEN EQUALLY-SPACED SAMPLES USING ZERO PADDING.
C-X(0:LX)=DATA VECTOR CONTAINING ORIGINAL SEQUENCE, X(0) THRU X(LX1).
C-LX1=LAST INDEX OF ORIGINAL DATA SEQUENCE.  (NOTE: X(LX1+1) THRU
C-    X(LX) CAN BE ANYTHING INITIALLY.)  COMPUTAION IS IN PLACE.
C-RATIO (R) MUST BE 1./(POWER OF 2.).
C-ROUTINE WORKS BY TAKING FFT OF X(0:LX1) PADDED WITH N-(LX1+1) ZEROS,
C- WHERE N=SMALLEST POWER OF 2 GT LX1, THEN PADDING THE FFT WITH
C- ZEROS TO INCREASE LENGTH TO N/R, THEN TAKING THE SCALED INVERSE FFT.
C-LX MUST BE BIG ENOUGH TO ACCOMODATE FINAL FFT, I.E.,
C-       LX GT ((SMALLEST POWER OF 2) GT LX1)/R.
C-LX2=LAST INDEX OF OUTPUT SEQUENCE, COMPUTED AS LX1/R.
C-IERROR=0  NO ERROR DETECTED
C-       1  RATIO IS NOT THE RECIPROCAL OF A POWER OF 2
C-       2  LX IS TOO SMALL FOR X(0:LX TO HOLD THE INTERPOLATED RESULT.
      DIMENSION X(0:LX)
      IERROR=1
      BASE=1.0
    1 BASE=BASE/2.
      IF(RATIO-BASE) 1,2,5
    2 IERROR=2
      N=1
    3 N=2*N
      IF(N.LE.LX1) GO TO 3
      N2=N/RATIO+0.5
      IF(N2.GE.LX) RETURN
      LX2=LX1/RATIO+0.5
      DO 4 K=0,LX
        IF(K.GT.LX1) X(K)=0.0
        X(K)=X(K)/N
    4 CONTINUE
      CALL SPFFTR(X,N)
      X(N)=X(N)/2.
      CALL SPIFTR(X,N2)
      IERROR=0
    5 RETURN
      END
C-  
C-*****************************************************************
C-*                   CHAPTER 11 ROUTINES                         *
C-*****************************************************************
C-
      SUBROUTINE SPNORM(X,Y,N,L,A,C,IERROR)
C-LATEST DATE: 11/13/85
C-SETS UP NORMAL EQN FOR LEAST-SQUARES POLYNOMIAL FIT: AB=C
C-X(0:N-1) & Y(0:N-1) ARE N-POINT INPUT DATA ARRAYS
C-L=ORDER OF POLYNOMIAL
C-A(0:L,0:L) = ARRAY RETURNED     C(0:L) = VECTOR RETURNED
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID N: N<=0 
C-       2      INVALID L: L<=0 OR L>N
      DIMENSION X(0:N-1),Y(0:N-1),A(0:L,0:L),C(0:L)
      IERROR=0
      IF(N.LE.0) IERROR=1
      IF(L.LE.0.OR.L.GT.N) IERROR=2
      IF(IERROR.NE.0) RETURN
      DO 2 J=1,L
        S1=0.
        S2=0.
        S3=0.
        DO 1 K=0,N-1
          S1=S1+X(K)**J
          S2=S2+X(K)**(L+J)
          S3=S3+Y(K)*(X(K)**J)
    1   CONTINUE
        A(0,J)=S1
        A(J,L)=S2
        C(J)=S3
    2 CONTINUE
      A(0,0)=N
      C(0)=0.
      DO 3 K=0,N-1
        C(0)=C(0)+Y(K)
    3 CONTINUE
      DO 5 I=1,L
        DO 4 J=0,L-1
          A(I,J)=A(I-1,J+1)
    4   CONTINUE
    5 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPGAUS(A,C,L,B,IERROR)
C-LATEST DATE: 11/13/85
C-USES GAUSSIAN ELIMINATION TO SOLVE AB=C MATRIX EQUATION
C-CAUTION:  DO NOT USE WITH ILL-CONDITIONED SYSTEMS
C-NO PIVOTING IS PERFORMED
C-A(0:L,0:L) = SQUARE MATRIX INPUT    C(0:L) = VECTOR INPUT
C-L=ORDER OF SYSTEM OF EQUATIONS
C-B(0:L) = SOLUTION VECTOR RETURNED
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID ORDER  L<=0
C-       2      ILL-CONDITIONED    PIVOT <1.E-10
      DIMENSION A(0:L,0:L),B(0:L),C(0:L)
      IERROR=1
      IF(L.LE.0) RETURN
      DO 1 I=0,L
        B(I)=0.0
    1 CONTINUE
      IERROR=2
      DO 5 I=0,L
        PIV=A(I,I)
        IF(ABS(PIV).LT.1.E-10) RETURN
        C(I)=C(I)/PIV
        DO 2 J=I,L
          A(I,J)=A(I,J)/PIV
    2   CONTINUE
        DO 4 II=I+1,L
          SCL=A(II,I)
          C(II)=C(II)-C(I)*SCL
          DO 3 J=I,L
            A(II,J)=A(II,J)-A(I,J)*SCL
    3     CONTINUE
    4   CONTINUE
    5 CONTINUE
      DO 8 I=L,0,-1
        B(I)=C(I)
        DO 6 J=I+1,L
          B(I)=B(I)-A(I,J)*B(J)
    6   CONTINUE
    8 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPORTH(Y,N,L,ORTHB,P,IERROR)
C-LATEST DATE: 11/13/85
C-GENERATES COEFFICIENTS FOR LEAST SQUARES FIT VIA ORTHOGONAL
C      POLYNOMIALS - LTH ORDER
C-DATA SAMPLES MUST OCCUR AT REGULAR INTERVALS
C-Y(0:N-1)=DATA ARRAY OF N SAMPLE POINTS
C-ORTHB(0:L)=COEFFICIENTS RETURNED
C-P(0:L,0:L)=WORK ARRAY USED INTERNALLY
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 OR L<=0
C-       2      N<L  CANNOT COMPUTE LEAST SQUARES FIT
      DIMENSION Y(0:N-1),ORTHB(0:L),P(0:L,0:L)
      IERROR=0
      IF(N.LE.0.OR.L.LE.0) IERROR=1
      IF(N.LT.L) IERROR=2
      IF(IERROR.NE.0) RETURN
      CALL SPLSMT(N,L,P)
      DO 5 I=0,L
        SN=0.
        SD=0.
        DO 2 NN=0,N-1
          SUM=0.
          DO 1 J=0,I
            SUM=SUM+P(I,J)*SPBFCT(NN,J)
    1     CONTINUE
          SN=SN+Y(NN)*SUM
          SD=SD+SUM**2
    2   CONTINUE
        ORTHB(I)=SN/SD
    5 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPPOLY(DX,Y,N,L,B,ORTHB,P,IERROR)
C-LATEST DATE: 11/13/85
C-GENERATES POLYNOMIAL COEFFICIENTS FOR LEAST SQUARES FIT
C-   B(0:L)=COEFFICIENTS RTND: B0+B1*X+....+BL*X**L
C-DX=POINT SPACING IN X DIRECTION (SAMPLE INTERVAL)
C-Y(0:N-1)=ARRAY OF N EQUALLY SPACED DATA SAMPLES
C-WORK ARRAYS:
C-      ORTHB(0:L) - ORTHOGONAL POLYNOMIAL COEFFICIENTS
C-      P(0:L,0:L) - MATRIX USED IN SPORTH AND SPSTRL
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 OR L<=0
C-       2      N<L  CANNOT COMPUTE LEAST SQUARES FIT
C-       3      DX <=0.  INVALID SAMPLE INTERVAL
      DIMENSION Y(0:N-1),B(0:L),ORTHB(0:L),P(0:L,0:L)
      CALL SPORTH(Y,N,L,ORTHB,P,IERROR)
      IF(DX.LE.0.) IERROR=3
      IF(IERROR.NE.0) RETURN
      DO 2 J=0,L
        B(J)=0.
        DO 1 I=J,L
          B(J)=B(J)+ORTHB(I)*P(I,J)
    1   CONTINUE
    2 CONTINUE
      CALL SPSTRL(L,P)
      DO 4 J=0,L
        SUM=0.
        DO 3 I=J,L
          SUM=SUM+B(I)*P(I,J)
    3   CONTINUE
        B(J)=SUM/(DX**J)
    4 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPLEVS(AVECT,C,L,B,WK,IERROR)
C-LATEST DATE: 05/27/86
C-LEVINSON'S ALGORITHM - SOLUTION OF AB=C MATRIX EQUATION
C-AVECT(0:L)= 1ST ROW OF SYMMETRIC TOEPLITZ MATRIX
C-C(0:L)= DATA VECTOR
C-B(0:L)=SOLUTION VECTOR RETURNED
C-WK(0:L)=WORK VECTOR USED INTERNALLY
C-IERROR=0     NO ERRORS DETECTED
C-       1     INVALID L<0
C-       2     APPROX DIVIDE BY ZERO - DENOMINATOR .LT. 1.E-10
      DIMENSION AVECT(0:L),C(0:L),B(0:L),WK(0:L)
      DOUBLE PRECISION U,V,W
      IERROR=0
      IF(L.LT.0) IERROR=1
      IF(ABS(AVECT(0)).LT.1.E-10) IERROR=2
      IF(IERROR.NE.0) RETURN
      DO 1 I=0,L
        WK(I)=0.0
        B(I)=0.0
    1 CONTINUE
      B(0)=C(0)/AVECT(0)
      IF(L.EQ.0) RETURN
      V=1.
      IERROR=2
      DO 5 M=0,L-1
       U=AVECT(M+1)/AVECT(0)
       W=(C(M+1)-B(0)*AVECT(M+1))/AVECT(0)
       IF(M.GT.0) THEN
        DO 2 K=1,M
         U=U-WK(M-K)*AVECT(K)/AVECT(0)
         W=W-B(K)*AVECT(M+1-K)/AVECT(0)
    2   CONTINUE
       ENDIF
       WK(M)=U/V
       IF(M.GT.0) THEN
        DO 3 N=0,(M-1)/2
         TEMP=WK(N)
         WK(N)=TEMP-WK(M)*WK(M-N-1)
         IF(M-N-1.NE.N) WK(M-N-1)=WK(M-N-1)-WK(M)*TEMP
    3   CONTINUE
       ENDIF
       V=V-WK(M)*U
       IF(ABS(V).LT.1.E-10) RETURN
       B(M+1)=W/V
       DO 4 K=0,M
        B(K)=B(K)-WK(M-K)*B(M+1)
    4  CONTINUE
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPDURB(AAVECT,L,B,IERROR)
C-LATEST DATE: 05/21/86
C-DURBIN'S ALGORITHM - SPECIAL CASE OF LEVINSON'S ALGORITHM
C-AAVECT(0:L+1) = AUGMENTED A DATA VECTOR
C-B(0:L) = SOLUTION VECTOR RETURNED
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID L   <0
C-       2      APPROX DIVIDE BY ZERO   DENOMINATOR .LT.1.E-10
      DIMENSION AAVECT(0:L+1),B(0:L)
      DO 1 I=0,L
        B(I)=0.0
    1 CONTINUE
      IERROR=0
      IF(L.LT.0) IERROR=1
      IF(ABS(AAVECT(0)).LT.1.E-10) IERROR=2
      IF(IERROR.NE.0) RETURN
      B(0)=-AAVECT(1)/AAVECT(0)
      IF(L.EQ.0) GO TO 7
      IERROR=2
      DO 5 NN=1,L
        GAMMA=0.
        GAMMAP=0.
        DO 2 I=1,NN
          GAMMA=GAMMA-AAVECT(I)*B(NN-I)
          GAMMAP=GAMMAP-AAVECT(I)*B(I-1)
    2   CONTINUE
        SCL=AAVECT(0)-GAMMAP
        IF(ABS(SCL).LT.1.E-10) GO TO 6
        BETA=-(AAVECT(NN+1)-GAMMA)/SCL
        DO 3 I=0,(NN-2)/2
          TMP=B(I)
          B(I)=B(I)+BETA*B(NN-1-I)
          IF(NN.GT.1) B(NN-1-I)=B(NN-1-I)+BETA*TMP
    3   CONTINUE
        IF(INT((NN-2)/2).NE.INT((NN-1)/2))
     +            B((NN-1)/2)=B((NN-1)/2)+BETA*B((NN-1)/2)
        B(NN)=BETA
    5 CONTINUE
      IERROR=0
    6 CONTINUE
    7 DO 8 I=0,L
        B(I)=-B(I)
    8 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPSTRL(L,S)
C-LATEST DATE: 11/13/85
C-GENERATES MATRIX OF STIRLING #S OF THE FIRST KIND
      DIMENSION S(0:L,0:L)
      DO 2 I=0,L
        S(I,0)=0.
        S(I,I)=1.
        DO 1 J=I+1,L
          S(I,J)=0.
    1   CONTINUE
    2 CONTINUE
      DO 3 I=2,L
        S(I,1)=-(I-1)*S(I-1,1)
    3 CONTINUE
      DO 5 I=3,L
        DO 4 J=2,I-1
          S(I,J)=S(I-1,J-1)-(I-1)*S(I-1,J)
    4   CONTINUE
    5 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPLSMT(N,L,P)
C-LATEST DATE: 11/13/85
C-GENERATES MATRIX USED FOR ORTHOGONAL POLYOMIALS
      DIMENSION P(0:L,0:L)
      DO 2 I=0,L
        P(I,0)=1.
        DO 1 J=I+1,L
          P(I,J)=0.
    1   CONTINUE
    2 CONTINUE
      DO 5 I=1,L
        DO 4 J=1,I
          P(I,J)=((-1.)**J)*SPBFCT(I,J)*SPBFCT(I+J,J)/
     +               (SPBFCT(N-1,J)*(SPBFCT(J,J)**2))
    4   CONTINUE
    5 CONTINUE
      RETURN
      END
C-
      FUNCTION SPBFCT(I1,I2)
C-LATEST DATE: 02/14/87
C-GENERATES (I1)!/(I1-I2)!=I1*(I1-1)*...*(I1-I2+1).
C-NOTE: 0!=1 AND SPBFCT(I,I)=SPBFCT(I,I-1)=I!.
      SPBFCT=0.
      IF(I1.LT.0.OR.I2.LT.0.OR.I2.GT.I1) RETURN
      SPBFCT=1.
      IF(I2.EQ.0) RETURN
      DO 1 I=I1,I1-I2+1,-1
        SPBFCT=SPBFCT*I
    1 CONTINUE
      RETURN
      END
C-  
C-*****************************************************************
C-*                   CHAPTER 12 ROUTINES                         *
C-*****************************************************************
C-
      SUBROUTINE SPNLMS(X,N,D,B,L,MU,SIG,AL,PX,IERROR)
C-LATEST DATE: 11/13/85
C-IMPLEMENTS NLMS ALGORITHM B(K+1)=B(K)+2*MU*E*X(K)/((L+1)*SIG)
C-X(O:N-1)=DATA VECTOR      INPUT SENT     OUTPUT RETURNED
C-D(0:N-1)=DESIRED SIGNAL VECTOR
C-N SPECIFIES NUMBER OF DATA POINTS IN X AND D
C-B(0:L)=ADAPTIVE COEFFICIENTS OF LTH ORDER FIR FILTER
C-MU=CONVERGENCE PARAMETER - DECLARE REAL
C-SIG=INPUT SIGNAL POWER ESTIMATE - UPDATED INTERNALLY
C-AL=FORGETTING FACTOR   SIG(K)=AL*(X(K)**2)+(1-AL)*SIG(K-1)
C-IERROR=0      NO ERRORS DETECTED
C-       1      INVALID ORDER   L<0
C-       2      INVALID CONVERGENCE PARAMETER   MU<=0 OR >=1
C-       3      INPUT POWER ESTIMATE  SIG<=0
C-       4      FORGETTING FACTOR   AL<0 OR =>1
C-       5      RESPONSE EXCEEDS 1.E10
      DIMENSION X(0:N-1),D(0:N-1),B(0:L),PX(0:L)
      REAL MU
      IERROR=0
      IF(L.LT.0) IERROR=1
      IF(MU.LE.0..OR.MU.GE.1.) IERROR=2
      IF(SIG.LE.0.) IERROR=3
      IF(AL.LT.0..OR.AL.GE.1.) IERROR=4
      IF(IERROR.NE.0) RETURN
      IERROR=5
      DO 5 K=0,N-1
        PX(0)=X(K)
        X(K)=0.
        DO 1 LL=0,L
          X(K)=X(K)+B(LL)*PX(LL)
    1   CONTINUE
        IF(ABS(X(K)).GT.1.E10) RETURN
        E=D(K)-X(K)
        SIG=AL*(PX(0)**2)+(1-AL)*SIG
        TMP=2*MU/((L+1)*SIG)
        DO 2 LL=0,L
          B(LL)=B(LL)+TMP*E*PX(LL)
    2   CONTINUE
        DO 3 LL=L,1,-1
          PX(LL)=PX(LL-1)
    3   CONTINUE
    5 CONTINUE
      IERROR=0
      RETURN
      END
C-  
C-*****************************************************************
C-*                   CHAPTER 13 ROUTINES                         *
C-*****************************************************************
C-
      FUNCTION SPMEAN(X,N)
C-LATEST DATE: 11/13/85
C-COMPUTES MEAN VALUE OF N-POINT DATA VECTOR X(0:N-1)
      DIMENSION X(0:N-1)
      SPMEAN=0.0
      IF(N.LE.0) RETURN
      DO 1 I=0,N-1
        SPMEAN=SPMEAN+X(I)
    1 CONTINUE
      SPMEAN=SPMEAN/N
      RETURN
      END
C-
      FUNCTION SPVARI(X,N)
C-LATEST DATE: 11/13/85
C-COMPUTES VARIANCE OF N-POINT DATA VECTOR X(0:N-1)
      DIMENSION X(0:N-1)
      SPVARI=0.0
      IF(N.LE.1) RETURN
      DO 1 I=0,N-1
        SPVARI=SPVARI+X(I)**2
    1 CONTINUE
      SPVARI=(SPVARI-N*(SPMEAN(X,N)**2))/(N-1.)
      RETURN
      END
C-
      SUBROUTINE SPLMTS(X,N,XMIN,IMIN,XMAX,IMAX)
C-LATEST DATE: 01/21/87
C-FINDS THE GLOBAL MINIMUM AND MAXIMUM OF THE N-POINT DATA
C-SEQUENCE IN ARRAY X(0:N-1).
C-XMIN AND XMAX ARE THE MINIMUM AND MAXIMUM DATA VALUES.
C-IMIN AND IMAX ARE THE ARRAY LOCATIONS CORRESPONDING TO 
C-THE FIRST OCCURRENCE OF THE RESPECTIVE EXTREME.
      DIMENSION X(0:N-1)
      IMIN=0
      IMAX=0
      IF(N.LE.1) GO TO 2
      DO 1 I=1,N-1
        IF(X(I).GT.X(IMAX))IMAX=I
        IF(X(I).LT.X(IMIN))IMIN=I
    1 CONTINUE
    2 XMIN=X(IMIN)
      XMAX=X(IMAX)
      RETURN
      END
C-
      SUBROUTINE SPLFIT(X,Y,N,A,B,IERROR)
C-LATEST DATE: 11/13/85
C-FITS STRAIGHT LINE TO DATA IN ARRAYS X(0:N-1) AND Y(0:N-1)
C-N SPECIFIES NUMBER OF DATA POINTS
C-EQUATION OF LINE:  Y=AX+B    A,B ARE RETURNED
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 
C-       2      ARITHMMETIC PROBLEM - DENOMINATOR APPROX 0.
      DIMENSION X(0:N-1),Y(0:N-1)
      A=0.
      B=0.
      IERROR=1
      IF(N.LE.0) RETURN
      XYSUM=0.
      XSUM=0.
      YSUM=0.
      X2SUM=0.
      DO 1 I=0,N-1
        XYSUM=XYSUM+X(I)*Y(I)
        XSUM=XSUM+X(I)
        YSUM=YSUM+Y(I)
        X2SUM=X2SUM+X(I)**2
    1 CONTINUE
      IERROR=2
      DEN=N*X2SUM-XSUM**2
      IF(DEN.LT.1.E-10) RETURN
      A=(N*XYSUM-XSUM*YSUM)/DEN
      B=SPMEAN(Y,N)-A*SPMEAN(X,N)
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPEXPN(X,Y,N,A,B,IERROR)
C-LATEST DATE: 11/13/85
C-FITS EXPONENTIAL CURVE TO DATA IN ARRAYS X(0:N-1) AND Y(0:N-1)
C-N SPECIFIES NUMBER OF DATA POINTS
C-EQUATION: Y=A(B**X)    A,B ARE RETURNED
C-DATA IN ARRAY Y IS CHANGED TO LOG DATA INTERNALLY
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 
C-       2      SPLFIT ERROR = 2
C-       3      Y DATA VALUE <=0.  CANNOT COMPUTE LOG
      DIMENSION X(0:N-1),Y(0:N-1)
      A=0.
      B=0.
      IERROR=1
      IF(N.LE.0) RETURN
      IERROR=3
      DO 1 I=0,N-1
        IF(Y(I).LE.0.) RETURN
        Y(I)=ALOG10(Y(I))
    1 CONTINUE
      CALL SPLFIT(X,Y,N,BLG,ALG,IERROR)
      IF(IERROR.NE.0) RETURN
      A=10.**ALG
      B=10.**BLG
      RETURN
      END
C-
      SUBROUTINE SPPWRC(X,Y,N,A,B,IERROR)
C-LATEST DATE: 11/13/85
C-FITS POWER FUNCTION CURVE TO DATA IN ARRAYS X(0:N-1) AND Y(0:N-1)
C-N SPECIFIES NUMBER OF DATA POINTS
C-EQUATION:  Y=A(X**B)   A,B ARE RETURNED
C-DATA IN X AND Y IS CONVERTED TO LOG INTERNALLY
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 
C-       2      SPLFIT ERROR = 2
C-       3      X OR Y DATA <=0.  CANNOT COMPUTE LOG
      DIMENSION X(0:N-1),Y(0:N-1)
      A=0.
      B=0.
      IERROR=1
      IF(N.LE.0) RETURN
      IERROR=3
      DO 1 I=0,N-1
        IF(X(I).LE.0..OR.Y(I).LE.0.) RETURN
        X(I)=ALOG10(X(I))
        Y(I)=ALOG10(Y(I))
    1 CONTINUE
      CALL SPLFIT(X,Y,N,B,ALG,IERROR)
      IF(IERROR.NE.0) RETURN
      A=10.**ALG
      RETURN
      END
C-
      SUBROUTINE SPXEXP(X,Y,N,A,B,IERROR)
C-LATEST DATE: 11/13/85
C-FITS CURVE OF FORM Y=BX*(E**AX) TO X(0:N-1) AND Y(0:N-1)
C-N SPECIFIES NUMBER OF POINTS    A,B ARE RETURNED
C-DATA IN X AND Y IS MODIFIED INTERNALLY
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 
C-       2      SPLFIT ERROR = 2
C-       3      NEGATIVE DATA - CANNOT COMPUTE LN
      DIMENSION X(0:N-1),Y(0:N-1)
      A=0.
      B=0.
      IERROR=1
      IF(N.LE.0) RETURN
      IERROR=3
      DO 1 I=0,N-1
        IF(X(I).LE.0..OR.Y(I).LE.0.) RETURN
        Y(I)=ALOG(Y(I))-ALOG(X(I))
    1 CONTINUE
      CALL SPLFIT(X,Y,N,A,BLN,IERROR)
      IF(IERROR.NE.0) RETURN
      B=EXP(BLN)
      RETURN
      END
C-
      SUBROUTINE SPRFTM(IDIR,X,N,T0,T10,T90,T100,IERROR)
C-LATEST DATE: 10/06/86
C-FINDS RISE/FALL TIME PARAMETERS FOR N-POINT DATA VECTOR X(0:N-1)
C-IDIR=1: RISE TIME      IDIR=-1: FALL TIME
C-LINEAR INTERPOLATION IS USED TO FIND T10 AND T90
C-TIMES RETURNED ASSUME NORMALIZED SAMPLE INTERVAL  T=1
C-T0: MINIMUM    T10: 10%       T90: 90%      T100: MAXIMUM
C-IERROR=0      NO ERRORS DETECTED
C-       1      N<=0 
C-       2      INVALID IDIR PARAMETER  .NE.1,-1
C-       3      T0=T100   MINIMUM AND MAXIMUM ARE SAME
      DIMENSION X(0:N-1)
      IERROR=0
      IF(N.LE.0) IERROR=1
      IF(IDIR.NE.1.AND.IDIR.NE.-1) IERROR=2
      IF(IERROR.NE.0) RETURN
      CALL SPLMTS(X,N,XMN,IMN,XMX,IMX)
      K100=IMX
      IF(IDIR.EQ.1)K0=0
      IF(IDIR.EQ.-1)K0=N-1
      DO 1 I=K100-IDIR,K0,-IDIR
        IF(X(I).GE.X(I+IDIR).AND.X(I).LT.X(K100)) THEN
          K0=I+IDIR
          GO TO 2
        ENDIF
    1 CONTINUE
    2 IERROR=3
      IF(X(K0).EQ.X(K100)) RETURN
      T0=K0
      T100=K100
      A90=.9*(X(K100)-X(K0))+X(K0)
      DO 5 I=K100,K0,-IDIR
        IF(X(I).LT.A90) GO TO 6
    5 CONTINUE
      I=K0
    6 T90=I+IDIR*(A90-X(I))/(X(I+IDIR)-X(I))
      A10=.1*(X(K100)-X(K0))+X(K0)
      DO 7 I=K100,K0,-IDIR
        IF(X(I).LT.A10) GO TO 8
    7 CONTINUE
      I=K0
    8 T10=I+IDIR*(A10-X(I))/(X(I+IDIR)-X(I))
      IERROR=0
      RETURN
      END
C-  
C-*****************************************************************
C-*                   CHAPTER 14 ROUTINES                         *
C-*****************************************************************
C-
      FUNCTION SPWNDO(ITYPE,N,K)
C-LATEST DATE: 11/13/85
C-THIS FUNCTION GENERATES A SINGLE SAMPLE OF A DATA WINDOW.
C-ITYPE=1(RECTANGULAR), 2(TAPERED RECTANGULAR), 3(TRIANGULAR),
C-      4(HANNING), 5(HAMMING), OR 6(BLACKMAN).
C-      (NOTE:  TAPERED RECTANGULAR HAS COSINE-TAPERED 10% ENDS.)
C-N=SIZE (TOTAL NO. SAMPLES) OF WINDOW.
C-K=SAMPLE NUMBER WITHIN WINDOW, FROM 0 THROUGH N-1.
C-  (IF K IS OUTSIDE THIS RANGE, SPWNDO IS SET TO 0.)
      PI=4.*ATAN(1.)
      SPWNDO=0.
      IF(ITYPE.LT.1.OR.ITYPE.GT.6) RETURN
      IF(K.LT.0.OR.K.GE.N) RETURN
      SPWNDO=1.
      GO TO (1,2,3,4,5,6), ITYPE
    1 RETURN
    2 L=(N-2)/10
      IF(K.LE.L) SPWNDO=0.5*(1.0-COS(K*PI/(L+1)))
      IF(K.GT.N-L-2) SPWNDO=0.5*(1.0-COS((N-K-1)*PI/(L+1)))
      RETURN
    3 SPWNDO=1.0-ABS(1.0-2*K/(N-1.0))
      RETURN
    4 SPWNDO=0.5*(1.0-COS(2*K*PI/(N-1)))
      RETURN
    5 SPWNDO=0.54-0.46*COS(2*K*PI/(N-1))
      RETURN
    6 SPWNDO=0.42-0.5*COS(2*K*PI/(N-1))+0.08*COS(4*K*PI/(N-1))
      RETURN
      END
C-
      SUBROUTINE SPMASK(X,LX,ITYPE,TSV,IERROR)
C-LATEST DATE: 02/20/87
C-THIS ROUTINE APPLIES A DATA WINDOW TO THE DATA VECTOR X(0:LX).
C-ITYPE=1(RECTANGULAR), 2(TAPERED RECTANGULAR), 3(TRIANGULAR),
C-      4(HANNING), 5(HAMMING), OR 6(BLACKMAN).
C-      (NOTE:  TAPERED RECTANGULAR HAS COSINE-TAPERED 10% ENDS.)
C-TSV=SUM OF SQUARED WINDOW VALUES.
C-IERROR=0 IF NO ERROR, 1 IF ITYPE OUT OF RANGE.
      DIMENSION X(0:LX)
      IERROR=1
      IF(ITYPE.LT.1.OR.ITYPE.GT.6) RETURN
      TSV=0.
      DO 1 K=0,LX
        W=SPWNDO(ITYPE,LX+1,K)
        X(K)=X(K)*W
        TSV=TSV+W*W
    1 CONTINUE
      IERROR=0
      RETURN
      END
C-
      SUBROUTINE SPUNWR(X,LX,IRD)
C-LATEST DATE: 11/13/85
C-SIMPLE PHASE UNWRAPPING ROUTINE, USEFUL WHERE PHASE WAS COMPUTED
C-  USING ATAN2 FUNCTION AND IN SIMILAR SITUATIONS WHERE THE PHASE
C-  IS WRAPPED INTO THE RANGE FROM -PI TO PI RADIANS.
C-X(0:LX)=SEQUENCE OF PHASE ANGLES IN RADIANS OR DEGREES, ALL
C-        ASSUMED TO BE OUTPUTS OF ATAN2 IN THE RANGE (-PI,PI) RAD.
C-IRD=1 TO INDICATE X IS IN RADIANS, OR 2 TO INDICATE DEGREES.
C-THE ROUTINE INSERTS A CORRECTION OF 2*PI OR 360 DEGREES WHEREVER
C-  THE PHASE JUMPS MORE THAN PI RADIANS.
      DIMENSION X(0:LX)
      ANGL=180.
      IF(IRD.EQ.1) ANGL=4.*ATAN(1.)
      COR=0.
      DO 2 K=1,LX
        DX=X(K)-(X(K-1)-COR)
        IF(ABS(DX).LE.ANGL) GO TO 1
        COR=COR-SIGN(2.*ANGL,DX)
    1   X(K)=X(K)+COR
    2 CONTINUE
      RETURN
      END
C-
      SUBROUTINE SPHILB(X,LX)
C-LATEST DATE: 12/17/86
C-GENERATES THE WEIGHTS OF AN FIR HILBERT TRANSFORMER.
C-AFTER EXECUTION THE WEIGHTS ARE IN X(0) THROUGH X(L-1), WHERE
C-  L=LX IF LX IS ODD OR L=LX+1 IF LX IS EVEN.
C-WHEN USED AS A CAUSAL FILTER, THE TRANSFORMER HAS APPROXIMATELY
C-  UNIT GAIN, A GROUP DELAY OF (L-1)/2 SAMPLES, PLUS
C-  APPROXIMATELY 90 DEGREES PHASE SHIFT AT ALL FREQUENCIES.
      DIMENSION X(0:LX)
      PI=4.*ATAN(1.)
      L2=LX/2
      X(L2)=0.
      X(LX)=0.
      DO 1 K=1,L2
        X(L2+K)=2.*(K-2*INT(K/2))/(PI*K)
        X(L2-K)=-X(L2+K)
    1 CONTINUE
      CALL SPMASK(X,2*L2,5,TSV,K)
      RETURN
      END
C-
      SUBROUTINE SPCHRP(X,LX,LX1,F1,F2,WORK,LX2,IERROR)
C-LATEST DATE: 11/27/85
C-COMPUTES THE CHIRP-Z TRANSFORM OF A COMPLEX SEQUENCE.
C-X=COMPLEX INPUT ARRAY CONTAINING THE COMPLEX SEQUENCE.
C-LX=LAST INDEX IN THE ARRAY X(0:LX).  LX+1 MUST BE A POWER OF 2.
C-LX1=LAST INDEX OF THE COMPLEX INPUT SEQUENCE, X(0)...X(LX1).
C-    LX1 MUST BE LESS THAN LX.
C-F1=FREQUENCY OF FIRST DFT COMPONENT.  (SAMPLING FREQ.=1.0.)
C-F2=FREQUENCY OF LAST DFT COMPONENT, GREATER THEN F1.
C-WORK=COMPLEX WORK ARRAY, DIMENSIONED COMPLEX WORK(0:LX).
C-AFTER EXECUTION DFT COMPONENTS, SPACED EVENLY FROM F1 THRU F2,
C-  ARE STORED IN X(0)...X(LX2).  THE ORIGINAL TIME SERIES IS LOST.
C-LX2=LAST FREQUENCY INDEX AS ABOVE, COMPUTED AS LX2=LX-LX1 DURING
C-     EXECUTION OF THE ROUTINE.
C-IERROR=0  NO ERRORS
C-       1  LX IS NOT GREATER THAN LX1
C-       2  F2 IS NOT GREATER THAN F1
C-       3  LX+1 IS NOT A POWER OF 2
      COMPLEX X(0:LX),WORK(0:LX),AM1,W2
      TP=8.*ATAN(1.)
      IERROR=1
      LX2=LX-LX1
      IF(LX2.LT.1) RETURN
      IERROR=2
      IF(F1.GE.F2) RETURN
      IERROR=3
      LXC=1
    1 LXC=2*LXC+1
      IF(LXC-LX) 1,2,6
    2 AM1=EXP(CMPLX(0.,-TP*F1))
      W2=EXP(CMPLX(0.,-TP*(F2-F1)/(2.*LX2)))
      DO 3 K=0,LX
        IF(K.LE.LX1) WORK(K)=(AM1*W2**K)**K*X(K)
        IF(K.GT.LX1) WORK(K)=0.
        IF(K.LE.LX2) X(K)=W2**(-K*K)
        IF(K.GT.LX2) X(K)=W2**(-(LX+1-K)**2)
    3 CONTINUE
      CALL SPFFTC(WORK,LX+1,-1)
      CALL SPFFTC(X,LX+1,-1)
      DO 4 K=0,LX
        X(K)=X(K)*WORK(K)
    4 CONTINUE
      CALL SPFFTC(X,LX+1,+1)
      DO 5 K=0,LX2
        X(K)=X(K)*W2**(K*K)/(LX+1)
    5 CONTINUE
      IERROR=0
    6 RETURN
      END
C-
      FUNCTION SPWLSH(LOGN,NSEQ,K)
C-LATEST DATE: 02/24/86
C-GENERATES A WALSH-ORDERED WALSH COEFFICIENT.  THE INPUTS ARE
C-     LOGN=LOG BASE 2 OF TRANSFORM ARRAY SIZE.
C-     NSEQ=SEQUENCY INDEX (0 THRU 2**LOGN-1).
C-     K=TIME INDEX (0 THRU 2**LOGN-1).
C-SPWLSH IS THE WALSH COEFFICIENT, EITHER -1.0 OR 1.0.
C-REF. -- AHMED AND RAO(SPRINGER-VERLAG,1975), PAGES 90-91.
C-
      X(M,N)=MOD(M/N,2)
      IS1=2**(LOGN-1)
      IS2=2
      SPWLSH=X(NSEQ,IS1)*X(K,1)
      DO 1 I=2,LOGN
        SPWLSH=SPWLSH+(X(NSEQ,IS1)+X(NSEQ,IS1/2))*X(K,IS2)
        IS1=IS1/2
        IS2=IS2*2
    1 CONTINUE
      SPWLSH=1.-2.*MOD(SPWLSH,2.)
      RETURN
      END
C-
